---
title: "Step 3"
output:
  html_document:
    toc: true
    toc_float: true
---

## Step 3a: Calculating the charge for a list of many peptides
Using the `pep_charge()` function, you were able to calculate the charge for 5 peptides at 3 pH values each. That involved using the function 15 times, which is doable, but slightly tedious. You could have done this same exercise with any of the online tools referenced above, and although it might not have been as educational, you would have achieved the same result. Now say that you have a mixture of 50, or 100, or even 1000 peptides. It suddenly becomes incredibly time-consuming to do all these calculations one at a time. Luckily, because you have the `pep_charge()` function available in a  versatile coding language, you are able to automate some of these calculations.  

## Exercise (3a)
Here is a list of 50 peptides that you have identified in your sample after a proteomics experiment:  

<font size="1" color="blue">HSTIFENLANK, HTFMGVVSLGSPSGEVSHPR, HTLNQIDEVK, IDVHLVPDR, IRLENEIQTYR, ITQVLHFTK, IVSSAMEPDREYHFGQAVR, KAEEEHLGILGPQLHADVGDK, KCPLPGTAAFK, KPVDEYKDCHLAQVPSHTVVAR, KPVEEYANCHLAR, KQTALVELVK, KVPQVSTPTLVEVSR, KYLYEIAR, LDELRDEGK, LKYENEVALR, LQHLENELTHDIITK, LSINTHPSQKPLSITVR, LVHVEEPHTETVR, LVNEVTEFAK, LVRPEVDVMCTAFHDNEETFLK, LVRPEVDVMCTAFHDNEETFLKK, LYHSEAFTVNFGDTEEAKK, MRPSTDTITVMVENSHGLR, NECFLQHKDDNPNLPR, PDYSVVLLLR, PSLVEQVFLDK, PVPGHVTVSICR, QEPERNECFLQHK, QEPERNECFLQHKDDNPNLPR, QHIEAIDVR, QNCELFEQLGEYK, QSVEADINGLRR, QEPERNECFLQHKDDNPNLPR, QTALVELVK, RHPDYSVVLLLR, RPCFSALEVDETYVPK, RYLYEIAR, SLHTLFGDK, SPAFTDLHLR, SSNLIILEEHLK, TFHADICTLSEK, THLAPYSDELR, THLPEVFLSK, VDLSFSPSQSLPASHAHLR, VFDEFKPLVEEPQNLIK, VHTECCHGDLLECADDR, VHTECCHGDLLECADDRADLAK, VLANGHAPYSR, VLGYVVEMQPK, VPQVSTPTLVEVSR, VQFELHYQEVK</font>  

And you want to know the charge of all of them at pH 7.

The code below imports them into R, storing them in a list called `peptides`. Copy and paste, and then run this in your R console.
```{r}
peptides <- list("HSTIFENLANK", "HTFMGVVSLGSPSGEVSHPR", "HTLNQIDEVK", "IDVHLVPDR", "IRLENEIQTYR", "ITQVLHFTK", "IVSSAMEPDREYHFGQAVR", "KAEEEHLGILGPQLHADVGDK", "KCPLPGTAAFK", "KPVDEYKDCHLAQVPSHTVVAR", "KPVEEYANCHLAR", "KQTALVELVK", "KVPQVSTPTLVEVSR", "KYLYEIAR", "LDELRDEGK", "LKYENEVALR", "LQHLENELTHDIITK", "LSINTHPSQKPLSITVR", "LVHVEEPHTETVR", "LVNEVTEFAK", "LVRPEVDVMCTAFHDNEETFLK", "LVRPEVDVMCTAFHDNEETFLKK", "LYHSEAFTVNFGDTEEAKK", "MRPSTDTITVMVENSHGLR", "NECFLQHKDDNPNLPR", "PDYSVVLLLR", "PSLVEQVFLDK", "PVPGHVTVSICR", "QEPERNECFLQHK", "QEPERNECFLQHKDDNPNLPR", "QHIEAIDVR", "QNCELFEQLGEYK", "QSVEADINGLRR", "QEPERNECFLQHKDDNPNLPR", "QTALVELVK", "RHPDYSVVLLLR", "RPCFSALEVDETYVPK", "RYLYEIAR", "SLHTLFGDK", "SPAFTDLHLR", "SSNLIILEEHLK", "TFHADICTLSEK", "THLAPYSDELR", "THLPEVFLSK", "VDLSFSPSQSLPASHAHLR", "VFDEFKPLVEEPQNLIK", "VHTECCHGDLLECADDR", "VHTECCHGDLLECADDRADLAK", "VLANGHAPYSR", "VLGYVVEMQPK", "VPQVSTPTLVEVSR", "VQFELHYQEVK")
```

You may not know exactly how to make your function run individually on many different peptides, but luckily you found another published script that does something related. In this case, the function `pep_length()` calculates the number of amino acids in a sequence. Then, below that, the author wrote a `for` loop that goes through a list of peptides (just like the one you have!) and calculates and prints the length for each one. Copy and paste the code below to your '.R' file, and run it.
```{r, results = 'hide'}
#function that returns the number of amino acids in a peptide
pep_length <- function(peptide) {
  length <- nchar(peptide)
  return(length)
}


#loop through a list of peptides and print out the peptide followed by the number of amino acids
for (pep in peptides) {
  #print out the peptides, one at a time. 'pep' is the variable that is a different peptide each loop
  print(pep)
  
  #calculate the length of the peptide
  peptide_length <- pep_length(peptide = pep)
  
  #print out the peptide length
  print(peptide_length)
}
```
If you ran the peptides list command earlier and this new block of code, you should see an output that printed each peptide followed by the number of amino acids it contains. Here are what the first three printouts should look like: 
```{r, echo=FALSE}
for (pep in peptides[1:3]) {
   #print out the peptides, one at a time. 'pep' is the variable that is a different peptide each loop
  print(pep)
  
  #calculate the length of the peptide
  peptide_length <- pep_length(peptide = pep)
  
  #print out the peptide length
  print(peptide_length)
}

```
Now you want to do essentially the same thing, but instead of printing out the length, print out the charge at pH 7. How can you modify the code to print out the charge? (Some hints are given below in white font... highlight the blank space below to read them.) <font color="purple">Take a screenshot of your modified code, and put it in the assignment.</font>

<font color="white">Hint 1: The modification should take place within the `for` loop.  
Hint 2: The modification involves exchanging one function for a different one.  
Hint 3: `pep_length()` is a function, just like `pep_charge()`. In this case, both include `peptide = pep`, but `pep_charge()` also takes an additional argument.</font>

If it worked correctly, you might get an output that includes the correct charges, but also includes the dataframe used to calculate the charge for each peptide. That is a lot of information, and not necessary in this case. Go back to your original `pep_charge()` function from exercise 1. Find the line that prints out the `net_charge_df` and delete it or comment it out (putting a `#` symbol in front of a line of code tells the computer to ignore it - this is referred to as 'commenting out a line'). Re-run that original `pep_charge()` function to save the change, and then re-run your 'for loop' to print out the values. Is that more manageable?  
```{r, echo=FALSE}
#Calculate Charge of a peptide at a specific pH
pep_charge <- function(peptide, pH = 7) {
  
  #convert any lowercase to uppercase
  peptide <- toupper(peptide)
  
  #create charge dataframe. This has a row for each ionizable group ('ion group'),
  #with its corresponding type of ion (basic or acidic - 'ion type'),
  #and an approximated pKa ('pKa'). These pKa values can be updated for different situations
  ion_group <- c('N_term', 'H', 'K', 'R', 'C', 'D', 'E', 'Y', 'C_term')
  ion_type <- c('basic', 'basic', 'basic', 'basic', 'acidic', 'acidic', 'acidic', 'acidic', 'acidic')
  #EMBOSS pKas
  pKa <- c(8.6, 6.5, 10.8, 12.5, 8.5, 3.9, 4.1, 10.1, 3.6)
  net_charge_df <- data.frame(ion_group, ion_type, pKa)
  
  #add a column for counting the number of each potentially charged residue, set at 0 to start
  net_charge_df$count <- 0
  #for each residue of interest, count the number of occurrences in the peptide
  for (i in 1:nrow(net_charge_df)) {
    net_charge_df$count[i] <- str_count(peptide, net_charge_df$ion_group[i])
  }
  #set the number of occurrences of the n-termini and c-termini to one each
  net_charge_df$count[net_charge_df$ion_group == 'N_term'] <- 1
  net_charge_df$count[net_charge_df$ion_group == 'C_term'] <- 1
  
  #create a column that stores the charge of a single instance of each ionizable group at the given pH.
  #set it to zero to start
  net_charge_df$single_charge <- 0
  
  #check if each ionizable group is acidic or basic.
  #calculate the charge for a single instance of each group. For the acidic groups, this charge will be negative (lost a proton)
  #these are calculated by determining the fraction of the group that is protonated vs. not protonated using the supplied pH and pKa values
  for (i in 1:nrow(net_charge_df)){
    if (net_charge_df$ion_type[i] == 'basic') {
      net_charge_df$single_charge[i] <- (10^(net_charge_df$pKa[i] - pH))/((10^(net_charge_df$pKa[i] - pH)) + 1)
    }
    if (net_charge_df$ion_type[i] == 'acidic') {
      net_charge_df$single_charge[i] <- -(10^(pH - net_charge_df$pKa[i]))/((10^(pH - net_charge_df$pKa[i])) + 1)
    }
  }
  
  #create a new column that is the net charge for each ionizable group (simply the charge of one instance * number of instances)
  net_charge_df$net_charge <- net_charge_df$count * net_charge_df$single_charge
  
  #sum all of the individual net charges to produce a total net charge of the peptide.
  total_net_charge <- sum(net_charge_df$net_charge)
  
  #print the dataframe. This can be commented in or out depending on whether this information is wanted
  #print(net_charge_df)

  #return the net charge value
  return(total_net_charge)
}

```
## Step 3b: Predicting m/z values for peptides in MALDI experiments
Matrix Assisted Laser Desorption Ionization Time of Flight (MALDI-TOF) mass spectrometry is an excellent way to quickly obtain mass values for analytes in a solution. In this technique, the sample is combined with a 'matrix' (usually some sort of organic acid). This matrix-sample combination is dried on a plate, and placed in the instrument. A laser excites the sample and desorbs both matrix and sample from the plate. In this high energy cloud, some analyte obtains an extra proton from the matrix and becomes positively charged. The m/z value of this analyte is measured by the time it takes to reach an ion detector, after being accelerated by an applied voltage. Analytes with smaller m/z values will travel faster than those with larger m/z values.

![*MALDI-TOF Schematic (Wikipedia)*](MALDI_TOF_EN.png){width=50%}  

## Exercise (3b)
You run each of the fractions from exercise 2 on a MALDI-TOF instrument, and obtain mass spectra, which show signal at specific m/z values. You want to calculate the expected m/z values for each of your peptides to see if they are present. Luckily, you find 2 more helpful published R functions. The first takes a peptide, and returns the mass of the peptide in Daltons. The second takes a mass and a charge value and returns m/z. Copy and paste both of these functions into R and run them.
```{r}
#calculate peptide mass
#create_dictionary. Each one letter code corresponds to a mass value. Must be run before the function
one_letter <- c('A','R','N','D','C','E','Q','G','H','I','L','K','M','F','P','S','T','W','Y','V')
masses <- list(71.03711381, 156.1011111, 114.0429275, 115.0269431, 103.0091845, 129.0425931, 128.0585775,
               57.02146374, 137.0589119, 113.084064, 113.084064, 128.0949631, 131.0404846, 147.0684139,
               97.05276388, 87.03202844, 101.0476785, 186.079313, 163.0633286, 99.06841395)
names(masses) <- one_letter

#the function to calculate the mass
pep_mass <- function(peptide){
  
  #convert the string to uppercase
  peptide <- toupper(peptide)
  
  #split the peptide into individual letters. [[1]] is required to select the individual values as opposed to a list
  splitpep <- strsplit(peptide,'')[[1]]
  
  #create a variable to store the mass. Set it to 0 to start
  total_mass <- 0.0
  
  #loop through each residue ('AA' in this case) in the peptide
  #first ensure that it is within the list of one letter codes above (by checking that it isn't null)
  #then add the corresponding mass for that one letter code to the total mass. masses[[AA]] accesses the mass corresponding to the specific amino acid
  for (AA in splitpep) {
    if (!is.null(masses[[AA]])) {
      total_mass <- total_mass + masses[[AA]]
    } 
  }
  
  #add the mass of H2O (for the n and c terminus... the masses used assume peptide bonds between amino acids)
  total_mass <- total_mass + 18.010565
    
  #return the total mass
  return(total_mass)
}

#A function that calculates m/z given a peptide and a pH
m_over_z <- function(peptide, pH = 7) {
  peptide_mass <- pep_mass(peptide)
  peptide_charge <- pep_charge(peptide, pH = 7)
  mass_charge_ratio <- peptide_mass / peptide_charge
  return(mass_charge_ratio)
}
```
Lets try it on one of our favorite peptides, DIAK. You should run this in your own console as well.
```{r}
m_over_z("DIAK", pH = 7)
```
Hmmm that output seems very high (and negative). What could be wrong? Lets try calculating charge and mass separately.
```{r}
pep_charge("DIAK", pH = 7)
pep_mass("DIAK")
```
The mass looks reasonable, but the charge is very close to zero (we actually knew this already from exercise 1). It turns out, when we are dividing mass / charge, we are dividing by a number that is essentially zero, causing the m/z value to skyrocket.  

If you think about MALDI however, we don't actually know what the pH is, and so assuming it to be 7 is probably not accurate. In addition, based on your extensive knowledge of MALDI with peptides, you remember that almost all peptides end up with a +1 charge (due to one proton) when they are ionized with this technique. How could you modify the `m_over_z()` function to make it applicable to MALDI? The important aspects are: 

* The charge will always be +1
* The mass will be the mass of the peptide *plus the mass of a proton* which is approximately 1.008 Da.  

<font color="purple">Take a screenshot of your modified `m_over_z()` function and paste it in your assignment. What are the expected MALDI m/z values for each peptide from Exercise 2?</font>
